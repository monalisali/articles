## JS中如何实现继承

现有Human、Solider构造函数，那如何创建一个Solider对象，使它可以**继承**Human的属性和方法呢？
```
function Human(){
  this.name = 'xx';
  this.skin = 'yellow';
}

Human.prototype.eat = function (){};
Human.prototype.drink = function (){};

function Solider(){
  this.id = 1;
  this.lifeValue = 50;
}

Solider.prototype.type = "解放军";
Solider.prototype.walk = function (){};
Solider.prototype.run = function (){};

```

还是要通过原型来实现

```

function Human(){
  this.name = 'xx';
  this.skin = 'yellow';
}

Human.prototype.eat = function (){};
Human.prototype.drink = function (){};

function Solider(){
  Human.call(this);// 继承Human的属性
  this.id = 1;
  this.lifeValue = 50;
}

Solider.prototype.type = "解放军";
Solider.prototype.walk = function (){};
Solider.prototype.run = function (){};
Solider.prototype.__proto__ = Human.prototype; //继承Human的函数

var s = new Solider(); //s就拥有了Solider和Human中所有的属性和函数

```

要继承Human的属性的话，就需要在Solider构造函数中先调用一下Human构造函数。因为我们需要把Solider构造函数中的临时对象（也就是solider对象）传递给Human，
所以就必须使用call。 `Human.call(this)` 一般写在Solider构造函数的第一句。

要继承Human的函数的话，就要把 `Solider.prototype`的__proto__指向`Human.prototype`。 
我们在(面向对象 new一文中)[https://github.com/monalisali/articles/blob/master/js/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%20new.md]
中提过：对象的__proto__指向其构造函数的prototype对象。 `Solider.prototype`本身也是对象，如果要让它拥有`Human.prototype`中的内容的话，
就自然要用__proto__去关联。

如果构造函数有参数时，该怎么处理？其实也是一样的方式。

```

function Human(option){
  this.name = option.name;
  this.skin = option.skin;
}

Human.prototype.eat = function (){};
Human.prototype.drink = function (){};

function Solider(option){
  Human.call(this,option);// 继承Human的属性
  this.id = option.id;
  this.lifeValue = 50;
}

Solider.prototype.type = "解放军";
Solider.prototype.walk = function (){};
Solider.prototype.run = function (){};
Solider.prototype.__proto__ = Human.prototype; //继承Human的函数

var s = new Solider({name:'tom', skin:'yellow',id:'100'}); //s就拥有了Solider和Human中所有的属性和函数

```


